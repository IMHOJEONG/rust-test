## 1. Hello

```rust
// 파라미터가 없고 아무것도 반환하지 않는 main이라는 이름의 함수를 정의
fn main() {
    
} 
```
-  러스트의 함수를 정의함, main 함수는 특별함 
   - 모든 실행 가능한 러스트 프로그램 내에서 첫 번째로 실행되는 코드
   - 좋은 스타일 : 여는 중괄호 기호를 함수 정의부와 같은 줄에 한 칸 띄워서 위치시키는 것
```rust
    println!("Hello, world!");
```
1. 러스트 스타일은 탭이 아닌 네 개의 스페이스로 들여쓰기를 함 
2. println!은 러스트 macro라 불림 
    - 함수로 불리려면 ! 없이 println으로 입력되었어야 할 것 
    - !이 보통의 함수 대신 매크로를 호출하고 있음을 의미한다는 것만 알아두자
3. "Hello, world!" String을 볼 수 있음 
    - 이 스트링을 println!의 인자로 넘기고, 이 스트링이 화면에 출력됨
4. 이 라인을 세미콜론 ; 으로 끝내는데,  이 표현식이 끝났고 다음 것이 시작될 준비가 되었음을 나타냄

### 컴파일과 실행은 개별적인 단계

- 러스트는 ahead-of-time compiled 언어
  - 우리가 프로그램을 컴파일하고, 그 실행파일을 다른 이들에게 주면, 
    - 그들은 러스트를 설치하지 않고도 이를 실행 가능 
  - 만일 우리가 누구에게 .rb, .py, .js 파일을 준다면, 
    각각 루비, 파이썬 or 자바스크립트 구현체가 설치 되어 있어야 함
    - 하지만, 이 언어들에선 하나의 커멘드로 우리 프로그램을 컴파일하고 실행할 수 있음
      - 언어 디자인에선 모든 것이 트레이드 오프

### Hello, Cargo!

- Cargo : 러스트의 빌드 시스템 및 패키지 매니저 
  - 대부분의 러스트 사용자들이 이 도구를 이용해 프로젝트를 관리
    - 우리 코드를 빌드하고 의존하고 있는 라이브러리를 다운로드해주고, 그 라이브러리들을 빌드하는 등 
      우리를 위한 많은 작업들을 다루기 때문
  - 의존성 : 우리의 코드가 필요로 하는 라이브러리를 의존성이라고 부름 
    
### Cargo를 사용해 프로젝트를 생성하기 

```shell
cargo new hello_cargo --bin // #1
cd hello_cargo 
```
1. hello_cargo라고 불리는 새로운 실행 가능한 바이너리를 생성 
  - cargo new에게 넘겨지는 --bin 인자가 라이브러리가 아닌 실행 가능한 애플리케이션으로 만들어줌 

- Cargo가 우리를 위해 두 개의 파일과 하나의 디렉토리를 생성한 것을 볼 수 있음 
  - Cargo.toml 파일 및 안에 main.rs 파일을 담고 있는 src 디렉토리 
    
```toml
[package]
name = "rust-test"
version = "0.1.0"
authors = ["rust-test"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

```
- TOML(Tom`s Obvious, Minimal Language) 포맷으로 작성됨 => Cargo의 환경설정 포맷
1. 첫 번째 라인 - "[package]" : 이후의 문장들이 패키지 환경설정라는 것을 나타내는 섹션의 시작지점
  - 이 파일에 더 많은 정보를 추가하기 위해, 다른 섹션들을 추가할 것 
2. 이후의 라인 - Cargo가 여러분의 프로그램을 컴파일하기 위해 필요로 하는 정보에 대한 설정 
  - 이름, 버전, 누가 작성했는가 
3. dependencies - 프로젝트의 의존성들의 리스트를 적을 수 있는 섹션의 시작점 

- 러스트에선 코드의 패키지를 crate라고 부름 
  - 의존성 섹션을 사용해야 함 
- Cargo가 코드를 src 디렉토리 안에 위치시킨다는 점 & 최상위 디렉토리에 Cargo.toml 환경 파일을 가지게 해준다는 점 

### Cargo 프로젝트를 빌드하고 실행하기 

```shell
cargo build 
```
- 현재 디렉토리 대신 target/debug/hello_cargo에 실행 파일을 생성 

- 처음으로 `cargo build`를 실행하는 것 => Cargo가 최상위 디렉토리에 Cargo.lock 이라는 새로운 파일을 생성하도록 함 

- `cargo run` : 한 번의 커멘드로 코드를 컴파일한 다음 결과 실행파일을 실행할 수 있음 

- Cargo는 파일들이 변경된 적이 없음을 알아내고, 따라서 해당 바이너리를 그저 실행했을 뿐 
  - 만인, 코드가 수정된 적이 있다면, Cargo는 그 프로젝트를 실행하기 전 다시 빌드할 것

- `cargo check` : 우리의 코드가 컴파일되는지를 빠르게 확인해주지만 실행파일을 생성하지 않음 
  - 'cargo build' 보다 빠름 : 이 커멘트가 실행파일을 생성하는 단계를 생략하기 때문
- 주로, 자신들의 프로그램을 작성하면서 컴파일되는지를 확인하기 위해 주기적으로 `cargo check`를 실행함 
  - 실행 파일을 사용할 준비가 되었을 때 `cargo build` 를 실행함 
    
- cargo를 사용하면, 어떠한 운영체제로 작업을 하든 상관없이 커맨드들이 동일하다는 점 

